//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @param {string} token
 */
CSSOM.parse = function parse(token) {

  var i = 0;

  /**
    "before-selector" or
    "selector" or
    "atRule" or
    "atBlock" or
    "before-name" or
    "name" or
    "before-value" or
    "value"
  */
  var state = "before-selector";

  var index;
  var buffer = "";

  var SIGNIFICANT_WHITESPACE = {
    "selector": true,
    "value": true,
    "atRule": true,
    "importRule-begin": true,
    "importRule": true,
    "atBlock": true
  };

  var styleSheet = new CSSOM.CSSStyleSheet;

  // @type CSSStyleSheet|CSSMediaRule|CSSFontFaceRule|CSSKeyframesRule
  var currentScope = styleSheet;

  // @type CSSMediaRule|CSSKeyframesRule
  var parentRule;

  var selector, name, value, priority="", styleRule, mediaRule, importRule, fontFaceRule, keyframesRule, keyframeRule;

  var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

  var parseError = function(message) {
    var lines = token.substring(0, i).split('\n');
    var lineCount = lines.length;
    var charCount = lines.pop().length + 1;
    var error = new Error(message + ' (line ' + lineCount + ', char ' + charCount + ')');
    error.line = lineCount;
    error.char = charCount;
    error.styleSheet = styleSheet;
    throw error;
  };

  for (var character; character = token.charAt(i); i++) {

    switch (character) {

    case " ":
    case "\t":
    case "\r":
    case "\n":
    case "\f":
      if (SIGNIFICANT_WHITESPACE[state]) {
        buffer += character;
      }
      break;

    // String
    case '"':
      index = token.indexOf('"', i + 1) + 1;
      if (!index) {
        parseError('Unmatched "');
      }
      buffer += token.slice(i, index);
      i = index - 1;
      switch (state) {
        case 'before-value':
          state = 'value';
          break;
        case 'importRule-begin':
          state = 'importRule';
          break;
      }
      break;

    case "'":
      index = token.indexOf("'", i + 1) + 1;
      if (!index) {
        parseError("Unmatched '");
      }
      buffer += token.slice(i, index);
      i = index - 1;
      switch (state) {
        case 'before-value':
          state = 'value';
          break;
        case 'importRule-begin':
          state = 'importRule';
          break;
      }
      break;

    // Comment
    case "/":
      if (token.charAt(i + 1) === "*") {
        i += 2;
        index = token.indexOf("*/", i);
        if (index === -1) {
          parseError("Missing */");
        } else {
          i = index + 1;
        }
      } else {
        buffer += character;
      }
      if (state === "importRule-begin") {
        buffer += " ";
        state = "importRule";
      }
      break;

    // At-rule
    case "@":
      if (token.indexOf("@media", i) === i) {
        state = "atBlock";
        mediaRule = new CSSOM.CSSMediaRule;
        mediaRule.__starts = i;
        i += "media".length;
        buffer = "";
        break;
      } else if (token.indexOf("@import", i) === i) {
        state = "importRule-begin";
        i += "import".length;
        buffer += "@import";
        break;
      } else if (token.indexOf("@font-face", i) === i) {
        state = "fontFaceRule-begin";
        i += "font-face".length;
        fontFaceRule = new CSSOM.CSSFontFaceRule;
        fontFaceRule.__starts = i;
        buffer = "";
        break;
      } else {
        atKeyframesRegExp.lastIndex = i;
        var matchKeyframes = atKeyframesRegExp.exec(token);
        if (matchKeyframes && matchKeyframes.index === i) {
          state = "keyframesRule-begin";
          keyframesRule = new CSSOM.CSSKeyframesRule;
          keyframesRule.__starts = i;
          keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
          i += matchKeyframes[0].length - 1;
          buffer = "";
          break;
        } else if (state == "selector") {
          state = "atRule";
        }
      }
      buffer += character;
      break;

    case "{":
      if (state === "selector" || state === "atRule") {
        styleRule.selectorText = buffer.trim();
        styleRule.style.__starts = i;
        buffer = "";
        state = "before-name";
      } else if (state === "atBlock") {
        mediaRule.media.mediaText = buffer.trim();
        currentScope = parentRule = mediaRule;
        mediaRule.parentStyleSheet = styleSheet;
        buffer = "";
        state = "before-selector";
      } else if (state === "fontFaceRule-begin") {
        if (parentRule) {
          fontFaceRule.parentRule = parentRule;
        }
        fontFaceRule.parentStyleSheet = styleSheet;
        styleRule = fontFaceRule;
        buffer = "";
        state = "before-name";
      } else if (state === "keyframesRule-begin") {
        keyframesRule.name = buffer.trim();
        if (parentRule) {
          keyframesRule.parentRule = parentRule;
        }
        keyframesRule.parentStyleSheet = styleSheet;
        currentScope = parentRule = keyframesRule;
        buffer = "";
        state = "keyframeRule-begin";
      } else if (state === "keyframeRule-begin") {
        styleRule = new CSSOM.CSSKeyframeRule;
        styleRule.keyText = buffer.trim();
        styleRule.__starts = i;
        buffer = "";
        state = "before-name";
      }
      break;

    case ":":
      if (state === "name") {
        name = buffer.trim();
        buffer = "";
        state = "before-value";
      } else {
        buffer += character;
      }
      break;

    case '(':
      if (state === 'value') {
        // ie css expression mode
        if (buffer.trim() == 'expression') {
          var info = parseCssExpression(token, i);

          if (info.error) {
            parseError(info.error);
          } else {
            buffer += info.expression;
            i = info.idx;
          }
        } else {
          index = token.indexOf(')', i + 1);
          if (index === -1) {
            parseError('Unmatched "("');
          }
          buffer += token.slice(i, index + 1);
          i = index;
        }
      } else {
        buffer += character;
      }
      break;

    case "!":
      if (state === "value" && token.indexOf("!important", i) === i) {
        priority = "important";
        i += "important".length;
      } else {
        buffer += character;
      }
      break;

    case ";":
      switch (state) {
        case "value":
          styleRule.style.setProperty(name, buffer.trim(), priority);
          priority = "";
          buffer = "";
          state = "before-name";
          break;
        case "atRule":
          buffer = "";
          state = "before-selector";
          break;
        case "importRule":
          importRule = new CSSOM.CSSImportRule;
          importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
          importRule.cssText = buffer + character;
          styleSheet.cssRules.push(importRule);
          buffer = "";
          state = "before-selector";
          break;
        default:
          buffer += character;
          break;
      }
      break;

    case "}":
      switch (state) {
        case "value":
          styleRule.style.setProperty(name, buffer.trim(), priority);
          priority = "";
        case "before-name":
        case "name":
          styleRule.__ends = i + 1;
          if (parentRule) {
            styleRule.parentRule = parentRule;
          }
          styleRule.parentStyleSheet = styleSheet;
          currentScope.cssRules.push(styleRule);
          buffer = "";
          if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
            state = "keyframeRule-begin";
          } else {
            state = "before-selector";
          }
          break;
        case "keyframeRule-begin":
        case "before-selector":
        case "selector":
          // End of media rule.
          if (!parentRule) {
            parseError("Unexpected }");
          }
          currentScope.__ends = i + 1;
          // Nesting rules aren't supported yet
          styleSheet.cssRules.push(currentScope);
          currentScope = styleSheet;
          parentRule = null;
          buffer = "";
          state = "before-selector";
          break;
      }
      break;

    default:
      switch (state) {
        case "before-selector":
          state = "selector";
          styleRule = new CSSOM.CSSStyleRule;
          styleRule.__starts = i;
          break;
        case "before-name":
          state = "name";
          break;
        case "before-value":
          state = "value";
          break;
        case "importRule-begin":
          state = "importRule";
          break;
      }
      buffer += character;
      break;
    }
  }

  return styleSheet;
};


/**
 * parse css expression() value
 *
 * @return {Object}
 *         - error:
 *         or
 *         - idx:
 *         - expression:
 *
 * Example:
 *
 * .selector {
 *    zoom: expression(documentElement.clientWidth > 1000 ? '1000px' : 'auto');
 * }
 */
function parseCssExpression(token, idx) {
  var character = '',
      STATES = {
        LITERAL: 0,
        STRING: 1,
        REGEXP: 2
      },
      state = STATES.LITERAL;
      string_sep = '',
      expression = '',
      error = '',
      paren = [];


  for (; ; ++idx) {
    character = token.charAt(idx);

    // end of token
    if (character == '') {
      error = 'css expression error: unfinished expression!';
      break;
    }

    switch(character) {
      case '(':
        if (state == STATES.LITERAL) {
          paren.push(character);
        }
        expression += character;
        break;

      case ')':
        if (state == STATES.LITERAL) {
          paren.pop(character);
        }
        expression += character;
        break;

      case '/':
        if (state == STATES.LITERAL) {
          var nextChar = token.charAt(idx + 1),
              regExp;
          if (nextChar == '/' || nextChar == '*') { // comment
            var commentEndChar,
                commentEndIdx;

            if (nextChar == '/') { // line comment
              commentEndChar = '\n';
            } else if (nextChar == '*') { // block comment
              commentEndChar = '*/';
            }

            commentEndIdx = token.indexOf(commentEndChar, idx + 1 + 1);
            if (commentEndIdx !== -1) {
              idx = commentEndIdx + commentEndChar.length - 1;
            } else {
              error = 'css expression error: unfinished comment in expression!';
            }
          } else if (regExp = parseJSRexExp(token, idx)) { // regexp?
            idx = regExp.idx;
            expression += regExp.regExp;
          } else {
            expression += character;
          }
        } else {
          expression += character;
        }
        break;

      // TODO: string_sep in regexp
      case "'":
      case '"':
        if (state == STATES.LITERAL) {
          state = STATES.STRING;
          string_sep = character;
        } else if (state == STATES.STRING) {
          if (string_sep == character) {
            var matched = expression.match(/\\+$/);
            if (!matched || matched[0].length % 2 == 0) {
              state = STATES.LITERAL;
              string_sep = '';
            }
          }
        }
        expression += character;
        break;

      default:
        expression += character;
        break;
    }

    if (error) {
      break;
    }

    // end of expression
    if (paren.length == 0) {
      break;
    }
  }

  var ret;
  if (error) {
    ret = {
      error: error
    }
  } else {
    ret = {
      idx: idx,
      expression: expression
    }
  }

  return ret;
}

/**
 * parse regexp in css expression
 *
 * @return {Object|false}
 *         - idx:
 *         - regExp:
 *         or 
 *         false
 */

/*

all legal RegExp
 
/a/
(/a/)
[/a/]
[12, /a/]

!/a/

+/a/
-/a/
* /a/
/ /a/
%/a/

===/a/
!==/a/
==/a/
!=/a/
>/a/
>=/a/
</a/
<=/a/

&/a/
|/a/
^/a/
~/a/
<</a/
>>/a/
>>>/a/

&&/a/
||/a/
?/a/
=/a/
,/a/

    delete /a/
        in /a/
instanceof /a/
       new /a/
    typeof /a/
      void /a/

*/
function parseJSRexExp(token, idx) {
  var before = token.substring(0, idx).trimRight(),
      legalRegx = [
        /^$/,
        /\($/,
        /\[$/,
        /\!$/,
        /\+$/,
        /\-$/,
        /\*$/,
        /\/\s+/,
        /\%$/,
        /\=$/,
        /\>$/,
        /\<$/,
        /\&$/,
        /\|$/,
        /\^$/,
        /\~$/,
        /\?$/,
        /\,$/,
        /delete$/,
        /in$/,
        /instanceof$/,
        /new$/,
        /typeof$/,
        /void$/,
      ];

  var isLegal = legalRegx.some(function(reg) {
    return reg.test(before);
  });

  if (!isLegal) {
    return false;
  } else {
    // TODO: read the regexp
  }

  return {
    idx: '',
    regExp: ''
  }
}


//.CommonJS
exports.parse = CSSOM.parse;
// The following modules cannot be included sooner due to the mutual dependency with parse.js
CSSOM.CSSStyleSheet = require("./CSSStyleSheet").CSSStyleSheet;
CSSOM.CSSStyleRule = require("./CSSStyleRule").CSSStyleRule;
CSSOM.CSSImportRule = require("./CSSImportRule").CSSImportRule;
CSSOM.CSSMediaRule = require("./CSSMediaRule").CSSMediaRule;
CSSOM.CSSFontFaceRule = require("./CSSFontFaceRule").CSSFontFaceRule;
CSSOM.CSSStyleDeclaration = require('./CSSStyleDeclaration').CSSStyleDeclaration;
CSSOM.CSSKeyframeRule = require('./CSSKeyframeRule').CSSKeyframeRule;
CSSOM.CSSKeyframesRule = require('./CSSKeyframesRule').CSSKeyframesRule;
///CommonJS
